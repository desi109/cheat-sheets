Rendering
----------
Rendering in React is the process of updating the user interface to reflect changes in state or props. This is typically
done by calling the `render` method of a component, which returns a React element that describes what should be displayed
on the screen.

                                  RENDERING != Updating the browser

Rendering a component is running the components function. But hte updating of the browser is done by React using
RECONCILIATION. Rendering means that the components function is executed again.Every time the state of a component
changes, its function is executed.
RECONCILIATION means the browser will only update the parts that were actually changed.



Pure Function
--------------
It is a function that always returns the same results. It does not depend on any external state or variables, and it
does not cause any side effects (like modifying global variables or changing the state of the application).

Example:
```javascript
const returnNumber = () => 5;        // Pure function - always returns 5
const addNumbers = (a, b) => a + b;  // Pure function - returns sum of a and b
const getUser = (id) => {
  return { id, name: 'John Doe' };   // Pure function - returns a new object with id and name
};
```


Side Effects (or just Effects)
-------------------------------
A side effect is anything that affects something outside of the component or needs to happen after the component renders.
Unlike rendering UI, which is predictable and pure, side effects might involve:
 - Fetching data from an API
 - Subscribing to something (like a WebSocket or an event listener)
 - Modifying the DOM manually
 - Setting a timer or interval


  React Tool for Side Effects:
useEffect
----------
React runs useEffect after rendering, so your app doesn’t block or lag when doing things like fetching data or setting
up subscriptions.

Example:
-----> UseEffectUserList.jsx
```javascript
import React, { useState, useEffect } from 'react';

function UseEffectUserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []); // empty array = run only once (on mount)

  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
export default UseEffectUserList;
```


-----> App.jsx
```javascript
import React from 'react'
import UseEffectUserList from './components/useEffectUserList'

function App() {
  return (
    <>
      <div>
        <h3>{'UseEffect User List output: '}</h3>
        <UseEffectUserList />
      </div>
    </>
  )
}

export default App
```

OUTPUT: The data from the API is loaded and displayed as a list of user names.
UseEffect User List output:    Leanne Graham
                                Ervin Howell
                               Clementine Bauch
                                     ...

Explanation:
 1 - State Setup with useState([]): You initialize users as an empty array.
                                    This will hold your list of users once the data is fetched.

 2 - Data Fetching with useEffect: The effect runs once, when the component mounts (because of the empty [] dependency array).
                                   It fetches user data from an API and saves it to state using setUsers.
   ```javascript
     useEffect(() => {
       fetch('https://jsonplaceholder.typicode.com/users')
         .then(res => res.json())
         .then(data => setUsers(data));
     }, []);
   ```

 3 - Rendering the List: As soon as users is updated with data, the component re-renders and displays the list.
   ```javascript
     {users.map(user => <li key={user.id}>{user.name}</li>)}
   ```

Why Hooks Here Are a Game-Changer?
- useEffect replaces class lifecycle methods like componentDidMount in just a few lines.
- useState makes the component reactive — any update to the data triggers a fresh render automatically.
- The logic is clean, organized, and reusable, all inside a functional component—no class needed!


The Purpose of useEffect and Side Effects
The goal of useEffect isn't to avoid re-rendering or control rendering directly—that's React's job, and it's already
optimized for that. Instead, useEffect is designed to handle side effects that happen outside of React's normal
rendering flow. It runs after the initial render and doesn't block it. That means the component can render quickly,
then go off and fetch data. Once the data arrives, you call setState, and React re-renders with the new data.



useMemo
----------
useMemo is a React hook that allows you to optimize performance by memoizing the result of a computation. It only
recalculates the value when its dependencies change, preventing unnecessary recalculations on every render.

Example:
-----> UseMemoExample.jsx
```javascript
import React, { useState, useMemo } from 'react';

function UseMemoExample() {
   const [number, setNumber] = useState(0);

   const doubled = useMemo(() => number * 2, [number]);

   return (
     <div>
       <p>Number: {number}</p>
       <p>Doubled: {doubled}</p>
       <button onClick={() => setNumber(number + 1)}>Increase</button>
     </div>
   );
 }

export default UseMemoExample;
```

-----> App.jsx
```javascript
import React from 'react';
import UseMemoExample from './components/UseMemoExample';

function App() {
  return (
    <div>
      <h1>useMemo Example</h1>
      <UseMemoExample />
    </div>
  );
}

export default App;
```

Explanation:
This example demonstrates how to use the useMemo hook in React to optimize performance by memoizing a computed value.
- useState(0) creates a state variable number initialized to 0.
- useMemo(() => number * 2, [number]) calculates doubled as number * 2 and only recalculates it when number changes.
- The UI displays the current number and its doubled value.
- Clicking the "Increase" button increments number by 1, which triggers a re-render and updates doubled.
- useMemo prevents unnecessary recalculations of doubled if number has not changed.



useRef
-------
useRef is a React hook that allows you to create a mutable reference that persists for the lifetime of the component.
It can be used to access DOM elements directly or to store mutable values that do not trigger re-renders when changed.

Example:
-----> UseRefExample.jsx
```javascript
import React, { useRef } from 'react';

function UseRefExample() {
  const inputRef = useRef(null);

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Click the button to focus me" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

export default UseRefExample;
```

-----> App.jsx
```javascript
import React from 'react';
import UseRefExample from './components/UseRefExample';

function App() {
  return (
    <div>
      <h1>useRef Example</h1>
      <UseRefExample />
    </div>
  );
}

export default App;
```

Explanation:
This example demonstrates how to use the useRef hook in React to directly access and control a DOM element.
- useRef(null) creates a reference object called inputRef that will be attached to the input element.
- The <input ref={inputRef} ... /> line connects the input field to inputRef.
- The focusInput function checks if the input element exists and then calls .focus() on it, which brings the cursor to
  the input field.
- When the "Focus Input" button is clicked, focusInput is called, and the input field is focused automatically.
- This is useful for managing focus or interacting with DOM elements without causing a re-render.
